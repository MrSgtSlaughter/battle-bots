<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BattleBots Arena - Choose Your Fighter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px 0;
        }

        #nameScreen, #selectionScreen, #gameScreen {
            text-align: center;
            padding: 20px;
        }

        #nameScreen {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #ff4444;
            border-radius: 10px;
            padding: 40px;
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        #nameScreen h1 {
            font-size: 3em;
            color: #ff4444;
            text-shadow: 0 0 20px #ff4444;
            margin-bottom: 20px;
        }

        #nameScreen input {
            padding: 15px;
            font-size: 1.2em;
            border: 2px solid #ff4444;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            margin: 10px 0;
            width: 300px;
        }

        #nameScreen button {
            padding: 15px 40px;
            font-size: 1.3em;
            background: #ff4444;
            border: none;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            margin: 10px;
            font-weight: bold;
            transition: all 0.3s;
        }

        #nameScreen button:hover {
            background: #ff6666;
            transform: scale(1.05);
            box-shadow: 0 0 20px #ff4444;
        }

        #selectionScreen {
            display: none;
            max-width: 1400px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
        }

        #selectionScreen h1 {
            font-size: 2.5em;
            color: #ff4444;
            text-shadow: 0 0 20px #ff4444;
            margin-bottom: 30px;
        }

        .robot-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-top: 30px;
        }

        .robot-card {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #555;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .robot-card:hover {
            border-color: #ff4444;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        .robot-card.selected {
            border-color: #ffff00;
            box-shadow: 0 0 40px rgba(255, 255, 0, 0.7);
        }

        .robot-preview {
            width: 100%;
            height: 150px;
            background: #0a0a0a;
            border: 2px solid #333;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .robot-name {
            font-size: 1.8em;
            color: #ff4444;
            margin-bottom: 10px;
        }

        .robot-description {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .robot-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-bar {
            text-align: left;
        }

        .stat-label {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 3px;
        }

        .stat-fill-container {
            height: 15px;
            background: #222;
            border-radius: 5px;
            overflow: hidden;
        }

        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00);
            border-radius: 5px;
        }

        #confirmBtn {
            margin-top: 30px;
            margin-bottom: 30px;
            padding: 20px 60px;
            font-size: 1.5em;
            background: #ff4444;
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        #confirmBtn:hover {
            background: #ff6666;
            transform: scale(1.05);
            box-shadow: 0 0 30px #ff4444;
        }

        #confirmBtn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #gameScreen {
            display: none;
            width: 100%;
            max-width: 1200px;
        }

        #gameCanvas {
            border: 4px solid #ff4444;
            border-radius: 10px;
            background: #0a0a0a;
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.6);
            display: block;
            margin: 0 auto;
        }

        #gameInfo {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff4444;
            border-radius: 10px;
        }

        .stat {
            font-size: 1.2em;
            padding: 10px;
        }

        .health-bar {
            width: 200px;
            height: 30px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #00ff00 100%);
            transition: width 0.3s;
        }

        #controls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff4444;
            border-radius: 10px;
            font-size: 0.9em;
        }

        #controls h3 {
            color: #ff4444;
            margin-bottom: 10px;
        }

        .control-row {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
        }

        #killFeed {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #ff4444;
            border-radius: 10px;
            min-width: 250px;
            max-height: 300px;
            overflow-y: auto;
        }

        .kill-message {
            margin: 5px 0;
            padding: 5px;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .weapon-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border: 3px solid #ff4444;
            border-radius: 10px;
            font-size: 1.5em;
            font-weight: bold;
        }

        .cooldown-indicator {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            border: 2px solid #ffaa00;
            border-radius: 10px;
            font-size: 1.2em;
        }

        @media (max-width: 1200px) {
            .robot-grid {
                grid-template-columns: 1fr;
            }
            
            #gameCanvas {
                max-width: 100%;
                height: auto;
            }
            
            #gameScreen {
                overflow-x: auto;
            }
        }
    </style>
</head>
<body>
    <div id="nameScreen">
        <h1>‚öîÔ∏è BATTLEBOTS ARENA ‚öîÔ∏è</h1>
        <p style="font-size: 1.2em; margin-bottom: 20px;">Enter the Arena of Destruction!</p>
        <input type="text" id="playerName" placeholder="Enter your bot name" maxlength="20">
        <br>
        <button id="nextBtn">NEXT ‚û°Ô∏è</button>
    </div>

    <div id="selectionScreen">
        <h1>ü§ñ CHOOSE YOUR BATTLEBOT ü§ñ</h1>
        <p style="font-size: 1.2em; opacity: 0.8;">Select your combat chassis</p>
        
        <div class="robot-grid">
            <div class="robot-card" data-robot="missile">
                <canvas class="robot-preview" id="previewMissile" width="400" height="150"></canvas>
                <div class="robot-name">üöÄ MISSILE DEVASTATOR</div>
                <div class="robot-description">
                    Heavy artillery platform with guided missile system. 
                    Fires homing missiles every 8 seconds that track enemies. 
                    Slow but devastating at range.
                </div>
                <div class="robot-stats">
                    <div class="stat-bar">
                        <div class="stat-label">SPEED</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 40%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">DAMAGE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 95%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">ARMOR</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 85%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">FIRE RATE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 30%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="robot-card" data-robot="laser">
                <canvas class="robot-preview" id="previewLaser" width="400" height="150"></canvas>
                <div class="robot-name">‚ö° LASER STRIKER</div>
                <div class="robot-description">
                    Balanced combat bot with rapid-fire laser weapons. 
                    High accuracy and fast projectiles. 
                    Perfect for hit-and-run tactics.
                </div>
                <div class="robot-stats">
                    <div class="stat-bar">
                        <div class="stat-label">SPEED</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 75%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">DAMAGE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 60%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">ARMOR</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 50%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">FIRE RATE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 85%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="robot-card" data-robot="saw">
                <canvas class="robot-preview" id="previewSaw" width="400" height="150"></canvas>
                <div class="robot-name">‚öôÔ∏è CHAINSAW RIPPER</div>
                <div class="robot-description">
                    Pure melee devastation - NO ranged weapons! 
                    Rush at enemies and shred them with spinning blades. 
                    Fastest bot with devastating close-range damage. High risk, high reward!
                </div>
                <div class="robot-stats">
                    <div class="stat-bar">
                        <div class="stat-label">SPEED</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 100%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">MELEE DAMAGE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 100%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">ARMOR</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 55%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">RANGE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 10%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="robot-card" data-robot="flame">
                <canvas class="robot-preview" id="previewFlame" width="400" height="150"></canvas>
                <div class="robot-name">üî• INFERNO SCORCHER</div>
                <div class="robot-description">
                    Area-control specialist with flamethrower arsenal. 
                    Continuous damage over time in a wide cone. 
                    Excels at controlling territory and groups.
                </div>
                <div class="robot-stats">
                    <div class="stat-bar">
                        <div class="stat-label">SPEED</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 60%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">DAMAGE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 70%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">ARMOR</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 65%"></div>
                        </div>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-label">FIRE RATE</div>
                        <div class="stat-fill-container">
                            <div class="stat-fill" style="width: 75%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <button id="confirmBtn" disabled>‚öîÔ∏è ENTER ARENA ‚öîÔ∏è</button>
    </div>

    <div id="gameScreen">
        <canvas id="gameCanvas" width="1400" height="900"></canvas>
        
        <div id="gameInfo">
            <div>
                <div class="stat">‚ö° Energy: <span id="energyDisplay">100</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="healthBar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">üéØ Kills: <span id="killsDisplay">0</span></div>
            <div class="stat">üíÄ Deaths: <span id="deathsDisplay">0</span></div>
            <div class="stat">‚è±Ô∏è Time: <span id="timeDisplay">0:00</span></div>
        </div>

        <div id="controls">
            <h3>üéÆ CONTROLS</h3>
            <div class="control-row">
                <span>‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è WASD/Arrow Keys - Move</span>
                <span>üî´ SPACE - Fire Weapon (Chainsaw: Ram to attack!)</span>
                <span>üîÑ ESC - Return to Menu</span>
            </div>
            <div class="control-row" style="color: #ffaa00; font-size: 0.85em;">
                <span>‚ò†Ô∏è Avoid Bottomless Pits!</span>
                <span>‚ö° Tesla Towers will FREEZE you!</span>
            </div>
        </div>

        <div class="weapon-indicator" id="weaponDisplay">
            üî´ WEAPON
        </div>

        <div class="cooldown-indicator" id="cooldownDisplay" style="display: none;">
            ‚è±Ô∏è Cooldown: <span id="cooldownTime">0</span>s
        </div>
    </div>

    <div id="killFeed" style="display: none;">
        <h3 style="color: #ff4444; margin-bottom: 10px;">üíÄ BATTLE LOG</h3>
        <div id="killFeedContainer"></div>
    </div>

    <script>
        // Game Variables
        let canvas, ctx;
        let playerName = '';
        let selectedRobotType = null;
        let gameLoop = null;
        let player = null;
        let aiBots = [];
        let projectiles = [];
        let particles = [];
        let hazards = {
            pits: [],
            teslaTowers: []
        };

        // Player stats
        let kills = 0;
        let deaths = 0;
        let startTime = Date.now();

        // Robot type definitions
        const ROBOT_TYPES = {
            missile: {
                name: 'MISSILE DEVASTATOR',
                speed: 1.0,
                health: 200,
                damage: 60,
                cooldown: 8000, // 8 seconds between missiles
                projectileSpeed: 4,
                color: '#4444ff',
                emoji: 'üöÄ',
                weaponType: 'HOMING_MISSILE'
            },
            laser: {
                name: 'LASER STRIKER',
                speed: 1.5,
                health: 150,
                damage: 20,
                cooldown: 800, // 0.8 seconds between shots
                projectileSpeed: 15,
                color: '#00ffff',
                emoji: '‚ö°',
                weaponType: 'LASER'
            },
            saw: {
                name: 'CHAINSAW RIPPER',
                speed: 3.0, // Fastest bot
                health: 120,
                damage: 50, // High melee damage
                cooldown: 100, // Just for collision check timing
                projectileSpeed: 0, // No projectiles
                color: '#ff8800',
                emoji: '‚öôÔ∏è',
                weaponType: 'MELEE' // Changed to MELEE
            },
            flame: {
                name: 'INFERNO SCORCHER',
                speed: 1.2,
                health: 160,
                damage: 12,
                cooldown: 500, // 0.5 seconds between flame bursts
                projectileSpeed: 8,
                color: '#ff4400',
                emoji: 'üî•',
                weaponType: 'FLAMETHROWER'
            }
        };

        let lastShot = 0;
        let energy = 100;

        // Draw robot previews
        function drawRobotPreview(canvasId, type) {
            const previewCanvas = document.getElementById(canvasId);
            if (!previewCanvas) return;
            const pctx = previewCanvas.getContext('2d');
            const centerX = previewCanvas.width / 2;
            const centerY = previewCanvas.height / 2;

            // Clear
            pctx.fillStyle = '#0a0a0a';
            pctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

            pctx.save();
            pctx.translate(centerX, centerY);

            const robotData = ROBOT_TYPES[type];
            const scale = 1.5;

            if (type === 'missile') {
                // Heavy tank-like bot with missile launchers
                // Main body
                pctx.fillStyle = '#2244aa';
                pctx.fillRect(-25 * scale, -20 * scale, 50 * scale, 40 * scale);
                
                // Armor plating
                pctx.fillStyle = '#334499';
                pctx.fillRect(-20 * scale, -15 * scale, 40 * scale, 30 * scale);
                
                // Missile launchers
                pctx.fillStyle = '#666';
                pctx.fillRect(-30 * scale, -15 * scale, 10 * scale, 30 * scale);
                pctx.fillRect(20 * scale, -15 * scale, 10 * scale, 30 * scale);
                
                // Missiles
                pctx.fillStyle = '#ff0000';
                pctx.fillRect(-28 * scale, -10 * scale, 6 * scale, 8 * scale);
                pctx.fillRect(-28 * scale, 2 * scale, 6 * scale, 8 * scale);
                pctx.fillRect(22 * scale, -10 * scale, 6 * scale, 8 * scale);
                pctx.fillRect(22 * scale, 2 * scale, 6 * scale, 8 * scale);
                
                // Cockpit
                pctx.fillStyle = '#00ffff';
                pctx.fillRect(-8 * scale, -8 * scale, 16 * scale, 16 * scale);
                
                // Details
                pctx.strokeStyle = '#ffff00';
                pctx.lineWidth = 3;
                pctx.strokeRect(-25 * scale, -20 * scale, 50 * scale, 40 * scale);
                
                // Hazard stripes
                pctx.fillStyle = '#ffff00';
                for (let i = -20; i < 20; i += 10) {
                    pctx.fillRect(i * scale, -20 * scale, 5 * scale, 5 * scale);
                    pctx.fillRect(i * scale, 15 * scale, 5 * scale, 5 * scale);
                }

            } else if (type === 'laser') {
                // Sleek, fast bot with laser arrays
                // Main body - angular
                pctx.fillStyle = '#0088aa';
                pctx.beginPath();
                pctx.moveTo(0, -25 * scale);
                pctx.lineTo(20 * scale, -10 * scale);
                pctx.lineTo(20 * scale, 10 * scale);
                pctx.lineTo(0, 25 * scale);
                pctx.lineTo(-20 * scale, 10 * scale);
                pctx.lineTo(-20 * scale, -10 * scale);
                pctx.closePath();
                pctx.fill();
                
                // Energy core
                pctx.fillStyle = '#00ffff';
                pctx.beginPath();
                pctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
                pctx.fill();
                
                // Laser cannons
                pctx.fillStyle = '#00aaff';
                pctx.fillRect(20 * scale, -5 * scale, 15 * scale, 10 * scale);
                pctx.fillRect(-35 * scale, -5 * scale, 15 * scale, 10 * scale);
                
                // Barrel tips
                pctx.fillStyle = '#00ffff';
                pctx.fillRect(35 * scale, -3 * scale, 5 * scale, 6 * scale);
                pctx.fillRect(-40 * scale, -3 * scale, 5 * scale, 6 * scale);
                
                // Glow effect
                pctx.shadowColor = '#00ffff';
                pctx.shadowBlur = 20;
                pctx.strokeStyle = '#00ffff';
                pctx.lineWidth = 2;
                pctx.beginPath();
                pctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
                pctx.stroke();
                pctx.shadowBlur = 0;
                
                // Wings
                pctx.fillStyle = '#006688';
                pctx.beginPath();
                pctx.moveTo(-20 * scale, -10 * scale);
                pctx.lineTo(-35 * scale, -18 * scale);
                pctx.lineTo(-25 * scale, -8 * scale);
                pctx.closePath();
                pctx.fill();
                pctx.beginPath();
                pctx.moveTo(-20 * scale, 10 * scale);
                pctx.lineTo(-35 * scale, 18 * scale);
                pctx.lineTo(-25 * scale, 8 * scale);
                pctx.closePath();
                pctx.fill();

            } else if (type === 'saw') {
                // Aggressive melee bot with spinning blades
                // Main body - compact and armored
                pctx.fillStyle = '#aa4400';
                pctx.fillRect(-18 * scale, -18 * scale, 36 * scale, 36 * scale);
                
                // Saw blade (front)
                pctx.save();
                pctx.translate(25 * scale, 0);
                pctx.rotate(Date.now() / 100);
                
                // Saw blade teeth
                pctx.fillStyle = '#cccccc';
                for (let i = 0; i < 12; i++) {
                    pctx.save();
                    pctx.rotate((i / 12) * Math.PI * 2);
                    pctx.fillRect(-2 * scale, -18 * scale, 4 * scale, 20 * scale);
                    pctx.restore();
                }
                
                // Saw center
                pctx.fillStyle = '#ff8800';
                pctx.beginPath();
                pctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
                pctx.fill();
                
                pctx.fillStyle = '#333';
                pctx.beginPath();
                pctx.arc(0, 0, 6 * scale, 0, Math.PI * 2);
                pctx.fill();
                
                pctx.restore();
                
                // Side armor spikes
                pctx.fillStyle = '#ff6600';
                pctx.beginPath();
                pctx.moveTo(-18 * scale, -18 * scale);
                pctx.lineTo(-25 * scale, -25 * scale);
                pctx.lineTo(-12 * scale, -18 * scale);
                pctx.closePath();
                pctx.fill();
                pctx.beginPath();
                pctx.moveTo(-18 * scale, 18 * scale);
                pctx.lineTo(-25 * scale, 25 * scale);
                pctx.lineTo(-12 * scale, 18 * scale);
                pctx.closePath();
                pctx.fill();
                
                // Details
                pctx.strokeStyle = '#ffaa00';
                pctx.lineWidth = 3;
                pctx.strokeRect(-18 * scale, -18 * scale, 36 * scale, 36 * scale);
                
                // Warning lights
                pctx.fillStyle = '#ff0000';
                pctx.fillRect(-15 * scale, -15 * scale, 8 * scale, 8 * scale);
                pctx.fillRect(-15 * scale, 7 * scale, 8 * scale, 8 * scale);
                pctx.fillRect(7 * scale, -15 * scale, 8 * scale, 8 * scale);
                pctx.fillRect(7 * scale, 7 * scale, 8 * scale, 8 * scale);

            } else if (type === 'flame') {
                // Flamethrower bot with fuel tanks
                // Main body
                pctx.fillStyle = '#aa2200';
                pctx.fillRect(-22 * scale, -18 * scale, 44 * scale, 36 * scale);
                
                // Fuel tanks
                pctx.fillStyle = '#dd4400';
                pctx.beginPath();
                pctx.arc(-15 * scale, 0, 12 * scale, 0, Math.PI * 2);
                pctx.fill();
                pctx.beginPath();
                pctx.arc(5 * scale, 0, 12 * scale, 0, Math.PI * 2);
                pctx.fill();
                
                // Tank details
                pctx.strokeStyle = '#ffaa00';
                pctx.lineWidth = 2;
                pctx.beginPath();
                pctx.arc(-15 * scale, 0, 12 * scale, 0, Math.PI * 2);
                pctx.stroke();
                pctx.beginPath();
                pctx.arc(5 * scale, 0, 12 * scale, 0, Math.PI * 2);
                pctx.stroke();
                
                // Flamethrower nozzle
                pctx.fillStyle = '#333';
                pctx.fillRect(22 * scale, -8 * scale, 20 * scale, 16 * scale);
                pctx.fillStyle = '#666';
                pctx.fillRect(35 * scale, -6 * scale, 10 * scale, 12 * scale);
                
                // Flame effect
                pctx.fillStyle = 'rgba(255, 150, 0, 0.6)';
                pctx.beginPath();
                pctx.moveTo(45 * scale, 0);
                pctx.lineTo(55 * scale, -5 * scale);
                pctx.lineTo(60 * scale, 0);
                pctx.lineTo(55 * scale, 5 * scale);
                pctx.closePath();
                pctx.fill();
                
                pctx.fillStyle = 'rgba(255, 50, 0, 0.4)';
                pctx.beginPath();
                pctx.moveTo(55 * scale, -5 * scale);
                pctx.lineTo(65 * scale, -8 * scale);
                pctx.lineTo(70 * scale, 0);
                pctx.lineTo(65 * scale, 8 * scale);
                pctx.lineTo(55 * scale, 5 * scale);
                pctx.closePath();
                pctx.fill();
                
                // Armor plating
                pctx.strokeStyle = '#ff4400';
                pctx.lineWidth = 3;
                pctx.strokeRect(-22 * scale, -18 * scale, 44 * scale, 36 * scale);
                
                // Vents
                pctx.fillStyle = '#ffaa00';
                for (let i = -15; i < 15; i += 8) {
                    pctx.fillRect(i * scale, -18 * scale, 3 * scale, 8 * scale);
                    pctx.fillRect(i * scale, 10 * scale, 3 * scale, 8 * scale);
                }
            }

            pctx.restore();
        }

        // Bot class
        class Bot {
            constructor(id, name, x, y, robotType, isPlayer = false) {
                this.id = id;
                this.name = name;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.robotType = robotType;
                this.robotData = ROBOT_TYPES[robotType];
                this.health = this.robotData.health;
                this.maxHealth = this.robotData.health;
                this.size = 25;
                this.speed = this.robotData.speed;
                this.color = this.robotData.color;
                this.isPlayer = isPlayer;
                this.lastShot = 0;
                this.target = null;
                this.sawRotation = 0;
            }

            update() {
                // AI behavior
                if (!this.isPlayer) {
                    this.aiUpdate();
                }

                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x < this.size) {
                    this.x = this.size;
                    this.vx *= -0.5;
                }
                if (this.x > canvas.width - this.size) {
                    this.x = canvas.width - this.size;
                    this.vx *= -0.5;
                }
                if (this.y < this.size) {
                    this.y = this.size;
                    this.vy *= -0.5;
                }
                if (this.y > canvas.height - this.size) {
                    this.y = canvas.height - this.size;
                    this.vy *= -0.5;
                }

                // Apply friction
                this.vx *= 0.92;
                this.vy *= 0.92;

                // Update saw rotation
                if (this.robotType === 'saw') {
                    this.sawRotation += 0.3;
                }

                // Melee collision for saw bots
                if (this.robotType === 'saw') {
                    this.checkMeleeCollisions();
                }
            }

            checkMeleeCollisions() {
                const now = Date.now();
                if (now - this.lastShot < 500) return; // Melee cooldown

                // Check collision with player
                if (this.id !== 'player' && player && player.health > 0) {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.size + player.size) {
                        if (player.takeDamage(this.robotData.damage)) {
                            deaths++;
                            addKillMessage('üíÄ', 'You were shredded by ' + this.name + '!');
                            respawn();
                        }
                        this.lastShot = now;
                        createExplosion(player.x, player.y, '#ff8800');
                        
                        // Knockback
                        player.vx += dx * 0.3;
                        player.vy += dy * 0.3;
                    }
                }

                // Check collision with AI bots
                if (this.isPlayer) {
                    aiBots.forEach(bot => {
                        const dx = bot.x - this.x;
                        const dy = bot.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.size + bot.size) {
                            if (bot.takeDamage(this.robotData.damage)) {
                                kills++;
                                addKillMessage('üéØ', 'You shredded ' + bot.name + '!');
                            }
                            this.lastShot = now;
                            createExplosion(bot.x, bot.y, '#ff8800');
                            
                            // Knockback
                            bot.vx += dx * 0.3;
                            bot.vy += dy * 0.3;
                        }
                    });
                }
            }

            aiUpdate() {
                let closestDist = Infinity;
                let closestTarget = null;

                if (player && player.health > 0) {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestTarget = player;
                    }
                }

                if (closestTarget) {
                    const dx = closestTarget.x - this.x;
                    const dy = closestTarget.y - this.y;
                    this.angle = Math.atan2(dy, dx);

                    // Special aggressive behavior for melee saw bots
                    if (this.robotType === 'saw') {
                        // Always rush towards target
                        this.vx += Math.cos(this.angle) * this.speed * 0.2;
                        this.vy += Math.sin(this.angle) * this.speed * 0.2;
                    } else {
                        // Adjust AI behavior based on bot type
                        const optimalRange = this.robotType === 'flame' ? 200 : 300;

                        if (closestDist > optimalRange) {
                            this.vx += Math.cos(this.angle) * this.speed * 0.1;
                            this.vy += Math.sin(this.angle) * this.speed * 0.1;
                        } else if (closestDist < optimalRange * 0.7) {
                            this.vx -= Math.cos(this.angle) * this.speed * 0.05;
                            this.vy -= Math.sin(this.angle) * this.speed * 0.05;
                        }

                        const now = Date.now();
                        if (now - this.lastShot > this.robotData.cooldown) {
                            this.shoot();
                            this.lastShot = now;
                        }
                    }
                } else {
                    if (Math.random() < 0.02) {
                        this.vx += (Math.random() - 0.5) * 1;
                        this.vy += (Math.random() - 0.5) * 1;
                    }
                }
            }

            shoot() {
                // Melee bots don't shoot projectiles
                if (this.robotType === 'saw') {
                    return;
                }

                const weaponType = this.robotData.weaponType;
                
                if (weaponType === 'FLAMETHROWER') {
                    // Spray of flame projectiles
                    for (let i = -2; i <= 2; i++) {
                        const spreadAngle = this.angle + (i * 0.15);
                        const proj = new Projectile(
                            this.x + Math.cos(spreadAngle) * this.size,
                            this.y + Math.sin(spreadAngle) * this.size,
                            spreadAngle,
                            this.robotData,
                            this.id
                        );
                        projectiles.push(proj);
                    }
                } else {
                    const proj = new Projectile(
                        this.x + Math.cos(this.angle) * this.size,
                        this.y + Math.sin(this.angle) * this.size,
                        this.angle,
                        this.robotData,
                        this.id
                    );
                    projectiles.push(proj);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Draw based on robot type
                if (this.robotType === 'missile') {
                    this.drawMissileBot();
                } else if (this.robotType === 'laser') {
                    this.drawLaserBot();
                } else if (this.robotType === 'saw') {
                    this.drawSawBot();
                } else if (this.robotType === 'flame') {
                    this.drawFlameBot();
                }

                ctx.restore();

                // Health bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(this.x - this.size, this.y - this.size - 15, this.size * 2, 8);
                
                const healthWidth = (this.health / this.maxHealth) * this.size * 2;
                ctx.fillStyle = this.health > 50 ? '#00ff00' : this.health > 25 ? '#ffff00' : '#ff0000';
                ctx.fillRect(this.x - this.size, this.y - this.size - 15, healthWidth, 8);

                // Name tag
                ctx.fillStyle = this.isPlayer ? '#ffff00' : '#fff';
                ctx.font = this.isPlayer ? 'bold 14px Arial' : 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x, this.y - this.size - 20);
            }

            drawMissileBot() {
                const s = this.size;
                
                // Main body
                ctx.fillStyle = this.isPlayer ? '#4466ff' : '#334499';
                ctx.fillRect(-s, -s * 0.8, s * 2, s * 1.6);
                
                // Missile launchers
                ctx.fillStyle = '#666';
                ctx.fillRect(-s * 1.2, -s * 0.6, s * 0.4, s * 1.2);
                ctx.fillRect(s * 0.8, -s * 0.6, s * 0.4, s * 1.2);
                
                // Missiles
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-s * 1.15, -s * 0.4, s * 0.25, s * 0.3);
                ctx.fillRect(-s * 1.15, s * 0.1, s * 0.25, s * 0.3);
                ctx.fillRect(s * 0.85, -s * 0.4, s * 0.25, s * 0.3);
                ctx.fillRect(s * 0.85, s * 0.1, s * 0.25, s * 0.3);
                
                // Cockpit
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-s * 0.3, -s * 0.3, s * 0.6, s * 0.6);
                
                if (this.isPlayer) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-s, -s * 0.8, s * 2, s * 1.6);
                }
            }

            drawLaserBot() {
                const s = this.size;
                
                // Angular body
                ctx.fillStyle = this.isPlayer ? '#00aaff' : '#0088aa';
                ctx.beginPath();
                ctx.moveTo(0, -s);
                ctx.lineTo(s * 0.8, -s * 0.4);
                ctx.lineTo(s * 0.8, s * 0.4);
                ctx.lineTo(0, s);
                ctx.lineTo(-s * 0.8, s * 0.4);
                ctx.lineTo(-s * 0.8, -s * 0.4);
                ctx.closePath();
                ctx.fill();
                
                // Energy core
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Laser cannons
                ctx.fillStyle = '#00aaff';
                ctx.fillRect(s * 0.8, -s * 0.2, s * 0.6, s * 0.4);
                
                // Glow
                if (this.isPlayer) {
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, s * 0.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }

            drawSawBot() {
                const s = this.size;
                
                // Compact body
                ctx.fillStyle = this.isPlayer ? '#cc5500' : '#aa4400';
                ctx.fillRect(-s * 0.7, -s * 0.7, s * 1.4, s * 1.4);
                
                // Spinning saw
                ctx.save();
                ctx.translate(s, 0);
                ctx.rotate(this.sawRotation);
                
                // Saw teeth
                ctx.fillStyle = '#cccccc';
                for (let i = 0; i < 12; i++) {
                    ctx.save();
                    ctx.rotate((i / 12) * Math.PI * 2);
                    ctx.fillRect(-s * 0.1, -s * 0.7, s * 0.2, s * 0.8);
                    ctx.restore();
                }
                
                // Saw center
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(0, 0, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                if (this.isPlayer) {
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-s * 0.7, -s * 0.7, s * 1.4, s * 1.4);
                }
            }

            drawFlameBot() {
                const s = this.size;
                
                // Main body
                ctx.fillStyle = this.isPlayer ? '#dd3300' : '#aa2200';
                ctx.fillRect(-s * 0.9, -s * 0.7, s * 1.8, s * 1.4);
                
                // Fuel tanks
                ctx.fillStyle = '#dd4400';
                ctx.beginPath();
                ctx.arc(-s * 0.6, 0, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(s * 0.2, 0, s * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Flamethrower nozzle
                ctx.fillStyle = '#333';
                ctx.fillRect(s * 0.9, -s * 0.3, s * 0.8, s * 0.6);
                
                if (this.isPlayer) {
                    ctx.strokeStyle = '#ff4400';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-s * 0.9, -s * 0.7, s * 1.8, s * 1.4);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    return true;
                }
                return false;
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, angle, robotData, shooterId) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.robotData = robotData;
                this.weaponType = robotData.weaponType;
                this.damage = robotData.damage;
                this.shooterId = shooterId;
                this.speed = robotData.projectileSpeed;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.lifetime = 0;
                this.maxLifetime = this.weaponType === 'FLAMETHROWER' ? 60 : 120;
                this.color = robotData.color;
                
                // Homing missile specific
                if (this.weaponType === 'HOMING_MISSILE') {
                    this.target = null;
                    this.findTarget();
                }
            }

            findTarget() {
                if (this.shooterId === 'player' && aiBots.length > 0) {
                    // Find closest bot
                    let closestDist = Infinity;
                    for (const bot of aiBots) {
                        const dx = bot.x - this.x;
                        const dy = bot.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < closestDist) {
                            closestDist = dist;
                            this.target = bot;
                        }
                    }
                } else if (player) {
                    this.target = player;
                }
            }

            update() {
                // Homing behavior
                if (this.weaponType === 'HOMING_MISSILE' && this.target && this.target.health > 0) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    // Gradually adjust angle towards target
                    const turnSpeed = 0.05;
                    const angleDiff = targetAngle - this.angle;
                    this.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnSpeed);
                    
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                }

                this.x += this.vx;
                this.y += this.vy;
                this.lifetime++;
                
                return this.lifetime < this.maxLifetime && 
                       this.x > -50 && this.x < canvas.width + 50 && 
                       this.y > -50 && this.y < canvas.height + 50;
            }

            draw() {
                ctx.save();
                
                if (this.weaponType === 'HOMING_MISSILE') {
                    // Missile
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-8, -4, 16, 8);
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(-8, -4);
                    ctx.lineTo(-12, 0);
                    ctx.lineTo(-8, 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Exhaust
                    ctx.fillStyle = 'rgba(255, 150, 0, 0.6)';
                    ctx.fillRect(-12, -2, 6, 4);
                    
                } else if (this.weaponType === 'LASER') {
                    // Laser bolt
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (this.weaponType === 'FLAMETHROWER') {
                    // Flame particle
                    ctx.globalAlpha = 0.7 - (this.lifetime / this.maxLifetime) * 0.5;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                ctx.restore();
            }

            checkCollision(bot) {
                if (bot.id === this.shooterId) return false;
                const dx = this.x - bot.x;
                const dy = this.y - bot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < bot.size;
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.color = color;
                this.life = 1;
                this.size = Math.random() * 5 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                return this.life > 0;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Bottomless Pit hazard
        class Pit {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            draw() {
                this.pulsePhase += 0.05;
                const pulse = Math.sin(this.pulsePhase) * 0.1 + 1;

                // Dark void center
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * pulse);
                gradient.addColorStop(0, '#000000');
                gradient.addColorStop(0.5, '#1a0033');
                gradient.addColorStop(1, '#330066');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Swirling edge effect
                ctx.strokeStyle = '#6600cc';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#6600cc';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Warning symbol
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ò†Ô∏è', this.x, this.y);
            }

            checkCollision(bot) {
                const dx = bot.x - this.x;
                const dy = bot.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.radius - bot.size;
            }
        }

        // Tesla Tower hazard
        class TeslaTower {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 80; // Freeze range
                this.size = 30;
                this.lastZap = 0;
                this.zapCooldown = 3000; // Zap every 3 seconds
                this.charging = false;
                this.zapTargets = [];
            }

            update() {
                const now = Date.now();
                
                // Check if ready to zap
                if (now - this.lastZap > this.zapCooldown - 1000) {
                    this.charging = true;
                } else {
                    this.charging = false;
                }

                // Zap nearby bots
                if (now - this.lastZap > this.zapCooldown) {
                    this.zapTargets = [];
                    
                    // Check player
                    if (player && player.health > 0) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < this.radius) {
                            this.zapTargets.push(player);
                        }
                    }

                    // Check AI bots
                    aiBots.forEach(bot => {
                        const dx = bot.x - this.x;
                        const dy = bot.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < this.radius) {
                            this.zapTargets.push(bot);
                        }
                    });

                    if (this.zapTargets.length > 0) {
                        this.lastZap = now;
                    }
                }
            }

            draw() {
                // Tower base
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size * 1.5);

                // Tower top
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(this.x - this.size / 2, this.y - this.size / 2);
                ctx.lineTo(this.x, this.y - this.size);
                ctx.lineTo(this.x + this.size / 2, this.y - this.size / 2);
                ctx.closePath();
                ctx.fill();

                // Tesla coil
                ctx.strokeStyle = this.charging ? '#ffff00' : '#00aaff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.size * 0.5, 10, 0, Math.PI * 2);
                ctx.stroke();

                if (this.charging) {
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - this.size * 0.5, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Range indicator (subtle)
                ctx.strokeStyle = 'rgba(0, 170, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw lightning to targets
                if (this.zapTargets.length > 0) {
                    this.zapTargets.forEach(target => {
                        this.drawLightning(this.x, this.y - this.size * 0.5, target.x, target.y);
                        
                        // Apply freeze effect
                        target.vx *= 0.3;
                        target.vy *= 0.3;
                        
                        // Visual freeze indicator
                        ctx.fillStyle = 'rgba(0, 170, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(target.x, target.y, target.size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // Warning label
                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö° TESLA', this.x, this.y + this.size);
            }

            drawLightning(x1, y1, x2, y2) {
                const segments = 8;
                const points = [{x: x1, y: y1}];
                
                for (let i = 1; i < segments; i++) {
                    const t = i / segments;
                    const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 30;
                    const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 30;
                    points.push({x, y});
                }
                points.push({x: x2, y: y2});

                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Thinner bright core
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            }
        }

        // Input handling
        const keys = {};
        window.addEventListener('keydown', (e) => {
            if (!e.key) return;
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            if (e.key === 'Escape' && gameLoop) {
                // Return to menu
                clearInterval(gameLoop);
                location.reload();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (!e.key) return;
            const key = e.key.toLowerCase();
            keys[key] = false;
        });

        function startGame() {
            if (!selectedRobotType) return;

            // Create player
            player = new Bot('player', playerName, canvas.width / 2, canvas.height / 2, selectedRobotType, true);

            // Create AI bots with random types
            const aiTypes = ['missile', 'laser', 'saw', 'flame'];
            const botNames = ['Destructor', 'Rampage', 'Crusher', 'Doom-Bot', 'Megabyte'];
            for (let i = 0; i < 5; i++) {
                const randomType = aiTypes[Math.floor(Math.random() * aiTypes.length)];
                const bot = new Bot(
                    'ai_' + i,
                    botNames[i],
                    Math.random() * (canvas.width - 200) + 100,
                    Math.random() * (canvas.height - 200) + 100,
                    randomType,
                    false
                );
                aiBots.push(bot);
            }

            // Generate hazards
            generateHazards();

            // Show game screen
            document.getElementById('selectionScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('killFeed').style.display = 'block';

            updateWeaponDisplay();

            // Start game loop
            startTime = Date.now();
            gameLoop = setInterval(update, 1000 / 60);
        }

        function update() {
            if (!player || !canvas || !ctx) return;

            // Handle input
            if (keys['w'] || keys['arrowup']) player.vy -= player.speed * 0.1;
            if (keys['s'] || keys['arrowdown']) player.vy += player.speed * 0.1;
            if (keys['a'] || keys['arrowleft']) player.vx -= player.speed * 0.1;
            if (keys['d'] || keys['arrowright']) player.vx += player.speed * 0.1;

            // Shooting
            if (keys[' ']) {
                // Melee bots don't shoot
                if (player.robotType === 'saw') {
                    // Melee attack is handled automatically in checkMeleeCollisions
                } else {
                    const now = Date.now();
                    if (now - lastShot > player.robotData.cooldown && energy >= 10) {
                        player.shoot();
                        lastShot = now;
                        energy -= player.robotData.weaponType === 'HOMING_MISSILE' ? 20 : 10;
                    }
                }
            }

            // Regenerate energy
            if (energy < 100) energy += 0.3;

            // Update player
            if (player.health > 0) {
                player.update();
            }

            // Update AI bots
            aiBots = aiBots.filter(bot => {
                if (bot.health > 0) {
                    bot.update();
                    return true;
                }
                return false;
            });

            // Respawn AI bots
            if (aiBots.length < 3) {
                const aiTypes = ['missile', 'laser', 'saw', 'flame'];
                const botNames = ['Destructor', 'Rampage', 'Crusher', 'Doom-Bot', 'Megabyte', 'Tombstone'];
                const randomType = aiTypes[Math.floor(Math.random() * aiTypes.length)];
                const bot = new Bot(
                    'ai_' + Date.now(),
                    botNames[Math.floor(Math.random() * botNames.length)],
                    Math.random() * (canvas.width - 200) + 100,
                    Math.random() * (canvas.height - 200) + 100,
                    randomType,
                    false
                );
                aiBots.push(bot);
                addKillMessage('‚ö°', bot.name + ' entered the arena');
            }

            // Update projectiles
            projectiles = projectiles.filter(proj => {
                const alive = proj.update();
                
                // Check player collision
                if (player.health > 0 && proj.checkCollision(player)) {
                    if (player.takeDamage(proj.damage)) {
                        deaths++;
                        addKillMessage('üíÄ', 'You were destroyed!');
                        respawn();
                    }
                    createExplosion(proj.x, proj.y, proj.color);
                    return false;
                }

                // Check AI collisions
                for (let i = 0; i < aiBots.length; i++) {
                    if (proj.checkCollision(aiBots[i])) {
                        if (aiBots[i].takeDamage(proj.damage)) {
                            if (proj.shooterId === 'player') {
                                kills++;
                                addKillMessage('üéØ', 'You destroyed ' + aiBots[i].name);
                            }
                        }
                        createExplosion(proj.x, proj.y, proj.color);
                        return false;
                    }
                }
                
                return alive;
            });

            // Update particles
            particles = particles.filter(p => p.update());

            // Update Tesla towers
            hazards.teslaTowers.forEach(tower => tower.update());

            // Check hazard collisions for player
            if (player.health > 0) {
                // Check pits
                for (const pit of hazards.pits) {
                    if (pit.checkCollision(player)) {
                        deaths++;
                        addKillMessage('‚ò†Ô∏è', 'You fell into the void!');
                        createExplosion(player.x, player.y, '#6600cc');
                        respawn();
                        break;
                    }
                }
            }

            // Check hazard collisions for AI bots
            aiBots.forEach((bot, index) => {
                for (const pit of hazards.pits) {
                    if (pit.checkCollision(bot)) {
                        createExplosion(bot.x, bot.y, '#6600cc');
                        bot.health = 0;
                        break;
                    }
                }
            });

            // Update UI
            if (player.health > 0) {
                document.getElementById('healthBar').style.width = player.health + '%';
            } else {
                document.getElementById('healthBar').style.width = '0%';
            }
            document.getElementById('energyDisplay').textContent = Math.floor(energy);
            document.getElementById('killsDisplay').textContent = kills;
            document.getElementById('deathsDisplay').textContent = deaths;
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timeDisplay').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Update cooldown display
            const cooldownRemaining = Math.max(0, (player.robotData.cooldown - (Date.now() - lastShot)) / 1000);
            if (cooldownRemaining > 0.1) {
                document.getElementById('cooldownDisplay').style.display = 'block';
                document.getElementById('cooldownTime').textContent = cooldownRemaining.toFixed(1);
            } else {
                document.getElementById('cooldownDisplay').style.display = 'none';
            }

            draw();
        }

        function updateWeaponDisplay() {
            if (player) {
                if (player.robotType === 'saw') {
                    document.getElementById('weaponDisplay').innerHTML = `${player.robotData.emoji} MELEE ATTACK`;
                } else {
                    document.getElementById('weaponDisplay').innerHTML = 
                        `${player.robotData.emoji} ${player.robotData.weaponType.replace('_', ' ')}`;
                }
            }
        }

        function generateHazards() {
            hazards.pits = [];
            hazards.teslaTowers = [];

            // Generate 3-5 bottomless pits
            const numPits = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numPits; i++) {
                let validPosition = false;
                let x, y;
                let attempts = 0;

                while (!validPosition && attempts < 50) {
                    x = Math.random() * (canvas.width - 300) + 150;
                    y = Math.random() * (canvas.height - 300) + 150;
                    
                    // Don't place too close to center or other hazards
                    const distToCenter = Math.sqrt(
                        Math.pow(x - canvas.width / 2, 2) + 
                        Math.pow(y - canvas.height / 2, 2)
                    );
                    
                    if (distToCenter > 200) {
                        validPosition = true;
                        // Check distance from other pits
                        for (const pit of hazards.pits) {
                            const dist = Math.sqrt(Math.pow(x - pit.x, 2) + Math.pow(y - pit.y, 2));
                            if (dist < 200) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                    hazards.pits.push(new Pit(x, y, 60));
                }
            }

            // Generate 2-3 Tesla towers
            const numTowers = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numTowers; i++) {
                let validPosition = false;
                let x, y;
                let attempts = 0;

                while (!validPosition && attempts < 50) {
                    x = Math.random() * (canvas.width - 300) + 150;
                    y = Math.random() * (canvas.height - 300) + 150;
                    
                    // Don't place too close to center or other hazards
                    const distToCenter = Math.sqrt(
                        Math.pow(x - canvas.width / 2, 2) + 
                        Math.pow(y - canvas.height / 2, 2)
                    );
                    
                    if (distToCenter > 250) {
                        validPosition = true;
                        
                        // Check distance from pits
                        for (const pit of hazards.pits) {
                            const dist = Math.sqrt(Math.pow(x - pit.x, 2) + Math.pow(y - pit.y, 2));
                            if (dist < 150) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        // Check distance from other towers
                        for (const tower of hazards.teslaTowers) {
                            const dist = Math.sqrt(Math.pow(x - tower.x, 2) + Math.pow(y - tower.y, 2));
                            if (dist < 250) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                    hazards.teslaTowers.push(new TeslaTower(x, y));
                }
            }
        }

        function respawn() {
            if (!player) return;
            player.x = Math.random() * (canvas.width - 200) + 100;
            player.y = Math.random() * (canvas.height - 200) + 100;
            player.health = player.maxHealth;
            player.vx = 0;
            player.vy = 0;
            energy = 100;
            createExplosion(player.x, player.y, player.color);
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function draw() {
            if (!canvas || !ctx) return;

            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 68, 68, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // Draw hazards (behind everything)
            hazards.pits.forEach(pit => pit.draw());
            hazards.teslaTowers.forEach(tower => tower.draw());

            // Draw particles
            particles.forEach(p => p.draw());

            // Draw projectiles
            projectiles.forEach(proj => proj.draw());

            // Draw bots
            if (player && player.health > 0) {
                if (player.vx !== 0 || player.vy !== 0) {
                    player.angle = Math.atan2(player.vy, player.vx);
                }
                player.draw();
            }

            aiBots.forEach(bot => bot.draw());

            // Draw arena border
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 20;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            ctx.shadowBlur = 0;
        }

        function addKillMessage(icon, message) {
            const container = document.getElementById('killFeedContainer');
            const div = document.createElement('div');
            div.className = 'kill-message';
            div.innerHTML = `${icon} ${message}`;
            container.insertBefore(div, container.firstChild);

            while (container.children.length > 8) {
                container.removeChild(container.lastChild);
            }
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Draw robot previews
            drawRobotPreview('previewMissile', 'missile');
            drawRobotPreview('previewLaser', 'laser');
            drawRobotPreview('previewSaw', 'saw');
            drawRobotPreview('previewFlame', 'flame');

            // Animate previews
            setInterval(() => {
                drawRobotPreview('previewMissile', 'missile');
                drawRobotPreview('previewLaser', 'laser');
                drawRobotPreview('previewSaw', 'saw');
                drawRobotPreview('previewFlame', 'flame');
            }, 50);
            
            // Name screen
            document.getElementById('nextBtn').addEventListener('click', () => {
                const nameInput = document.getElementById('playerName');
                playerName = nameInput.value.trim() || 'Player_' + Math.floor(Math.random() * 1000);
                document.getElementById('nameScreen').style.display = 'none';
                document.getElementById('selectionScreen').style.display = 'block';
            });
            
            document.getElementById('playerName').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('nextBtn').click();
                }
            });

            // Robot selection
            document.querySelectorAll('.robot-card').forEach(card => {
                card.addEventListener('click', () => {
                    document.querySelectorAll('.robot-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedRobotType = card.dataset.robot;
                    document.getElementById('confirmBtn').disabled = false;
                });
            });

            document.getElementById('confirmBtn').addEventListener('click', startGame);
        });
    </script>
</body>
</html>